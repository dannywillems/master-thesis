\chapter{System $F_{<:}$}
\label{chapter:system-f-sub}

Dans les chapitres \ref{chapter:lambda-calculus-with-records} et
\ref{chapter:system-f}, nous avons défini deux notions de polymorphisme: le
polymorphisme par sous-typage à travers les enregistrements et le polymorphisme
paramétré.

Les deux calculs permettent de résoudre deux problèmes différents :
\begin{enumerate}
  \item le sous-typage permet d'affiner notre relation de typage à travers la
    relation $<:$. Par exemple, il nous est permi de définir la fonction
    identité sur les réels ($\lambdaExpr{x : \real} x$) et de l'appliquer à un
    entier car $\naturel$ est un sous-type de $\real$.
  \item le polymorphisme paramétré permet de quantifier sur les types et de
    créer des fonctions indépendamment du types grâce aux abstractions de types
    pour ensuite les appliquer aux types souhaités. Par exemple, nous pouvons
    définir la fonction identité polymorphe $\lambdaExprType{X}{\lambdaExpr{x :
    X}{x}}$ et les appliquer aux types $\real$ et $\naturel$, mais également à
    n'importe quel autre type comme $\naturel \rightarrow \real$ ou encore $\real
    \rightarrow (\naturel \rightarrow \real)$.
\end{enumerate}

Dans ce chapitre, nous allons unifier ces deux notions en un langage appelé
System $F_{<:}$\footnote{prononcé \og system F sub \fg}. L'idée principale de
System $F_{<:}$ est d'élargir notre relation de sous-typage sur les variables de
types pour les borner et ainsi restreindre les types qui peuvent être appliqués
aux abstractions de type. De cette façon, une même abstraction de type dépendante d'une
variable $X$, bornée supérieurement par $\real$, pourra accepter les types $\naturel$ et
$\real$, mais pas $\naturel \rightarrow \real$ ou encore $\real \rightarrow
\real$. Nous ne considérons donc plus seules les variables de types, mais liées
à une borne supérieure. Nous notons $X <: T$ pour dire que la variable de type
$X$ est borné supérieurement par $T$.  

Ajouter une borne supérieure permet d'affiner le type de la variable $X$ en
obligeant le type appliqué à avoir certaines caractéristiques. Par exemple, la
fonction $\lambdaExprType{X <: \left\{ z : \real \right\}}{\lambdaExpr{x :
    X}{\, x.z}}$ oblige, lors d'une application de type, de donner un type
enregistrement avec au moins le champ $z$ qui est de type réel.

\section{Syntaxe}


\section{Sémantique}

\section{Contexte de typage}

\section{Règles de typage}

\section{Sureté}

Les théorèmes de préservation et de progression restent vrais pour System
$F_{<:}$. Cependant, nous ne les démontrerons pas car ils nécessitent des lemmes
techniques et ce n'est pas le sujet principal de ce document. La structure
et les techniques restent les mêmes : lemme d'inversion des relations de typage,
lemme des formes canoniques, lemme d'inversion de la relation de sous-typage, lemme de
substitution des types, preuve par induction structurelle, etc.
Des preuves des théorèmes peuvent être trouvées dans
\cite{tapl-bounded-quantification}.