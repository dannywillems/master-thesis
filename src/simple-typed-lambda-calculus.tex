\chapter{$\lambda$-calcul simplement typé.}

Dans le chapitre 1, nous avons défini la syntaxe et la sémantique d'un calcul
appelé le $\lambda$-calcul non typé. Nous allons maintenant ajouter une notion de types à
chaque terme de notre calcul, ce qui nous mènera au $\lambda$-calcul simplement typé.

\section{Typage, contexte de typage et règle d'inférence}

Le typage consiste à classer les termes en fonction de leur nature. Par exemple,
une abstraction est interprétée comme une fonction prenant un paramètre et
renvoyant un terme. Nous représentons cela par le type $\rightarrow$, appelé
couramment \textit{type flèche}. Un type flèche dépend naturellement de deux autres types : le
type du terme qu'il prend en paramètre (disons $T_{1}$) et le type du terme
qu'il retourne (disons $T_{2}$). Dans ce cas, l'abstraction est dite de type
$T_{1} \rightarrow T_{2}$, lu \og $T_{1}$ flèche $T_{2}$ \fg. Un
autre exemple est l'application. Une application $u \, v$ représentant une
application de $v$ à la fonction $u$, il serait naturel de dire que $u$ est un
type flèche dont le type de son paramètre est le type de $v$.

\begin{definition} [Relation de typage]
  Soit $\Lambda$ un ensemble de termes.
  Soit $\tau$ un ensemble, appelé \textbf{ensemble des types}, dont les éléments
  sont notés $T$.

  On définit une relation binaire $R$, appelée \textbf{relation de typage}, entre les
  termes et les éléments de $\tau$.
  
  On dit que \textbf{le terme $t \in \Lambda$ a le type $T \in \tau$} si $(t, T)
  \in R$, noté le plus souvent $t : T$. Si un terme $t$ est en relation avec au
  moins un type $T$, on dit que $t$ est \textbf{bien typé}.
\end{definition}

Cette définition de la relation de typage est générale car il suffit de se
donner un ensemble de termes et un ensemble de types. Dans ce chapitre, nous
allons nous focaliser sur les termes du $\lambda$-calcul non typé. Dans les
prochains chapitres, nous ajouterons des autres termes comme les enregistrements
et nous devrons en conséquence donner un type à ces nouveaux termes.

Dans ce chapitre, nous allons travailler avec l'ensemble des types dit
\textit{simples}.

\begin{definition}
  Soit $B$ un ensemble de type appelé de \textbf{types de bases}.
  L'ensemble des \textbf{types simples} est défini par la grammaire suivante:
  \begin{align*}
    T ::= & \, & \text{types} \\
          & \; B & \text{base} \\
          & \; T \rightarrow T & \text{type des fonctions}
  \end{align*}
\end{definition}

L'ensemble de base $B$ est assez naturel : il existe souvent dans les langages
des types dit de bases ou primitifs.

%Le typage est donc un moyen de spécifier l'appartenance de certains
%$\lambda$-termes à un ensemble précis de type et ainsi réduire les opérations
%possibles sur ces $\lambda$-termes.

%Dans le chapitre 1 sur le $\lambda$-calcul non typé, nous avons défini une
%relation d'évaluation, noté $\rightarrow$. Nous pouvons nous demander comment la
%relation de typage est compatible avec la relation $\rightarrow$.

\subsection*{Contexte et jugement de typage}

Nous avons déjà mentionné que, naturellement, les abstraction $\lambdaExpr{x}{t}$ ont le type
flèche, par exemple $T_{1} \rightarrow T_{2}$. Cependant, comment pouvons nous
connaître le type des arguments, c'est-à-dire le type du paramètre que la
fonction attend ? Deux solutions sont couramment utilisées : soit ajouter le type
dans le terme de l'abstraction soit étudier le type de corps de la fonction et
en déduire le type que le paramètre devrait avoir.
Dans la suite, nous utiliserons la première solution. Le terme de l'abstraction
se voit alors ajouter un type à son argument et devient $\lambdaExpr{x : T}{t}$.
La syntaxe des termes devient alors:

\begin{align*}
  t ::= & \, & \text{terme} \\
        & \; x & \text{var} \\
        & \; t \, t & \text{app} \\
        & \; \lambdaExpr{x : T}{t} & \text{abs}
\end{align*}

Avant de discuter des règles de typages, il convient de remarquer qu'il est
nécéssaire de connaitre certaines informations quand nous souhaitons typer des
termes. En effet, si nous prenons le terme $\lambdaExpr{x : T} y$ et que nous
souhaitons le typer, il est nécessaire de connaître le type de $y$. Cela nous
amène à la notion de \textit{contexte de typage}.

\begin{definition} [Contexte de typage]
  Un \textbf{contexte de typage}, noté $\Gamma$, est un ensemble fini de couple $(x_{i},
  T_{i})$ où $x_{i}$ est une variable et $T_{i}$ est un type. Chaque $x_{1}$ est différent.
  
  L'union d'un contexte de typage $\Gamma$ avec un couple $(x, T)$ est noté
  $\Gamma, x : T$. Le contexte vide est noté $\emptyset$.
\end{definition}

La relation de typage devient alors une relation à trois composantes : le
contexte, le terme et le type. Nous parlons alors de \textit{jugement de typage}.

\begin{definition} [Jugement de typage]
  \textbf{Un jugement de typage} est un triplet $(\Gamma, t, T)$ où $\Gamma$ est un
  contexte de typage, $t$ un terme et $T$ un type. Nous le notons le plus
  souvent $\Gamma \vdash t : T$ et nous disons \og $t$ à le type $T$ sous les
  hypothèses $\Gamma$\footnote{ou encore dans le contexte $\Gamma$}. Si $\Gamma$
  est vide, nous omettons $\emptyset$ et le jugement devient $\vdash t : T$.
\end{definition}

\subsection*{Règle de typage et arbre de dérivation}

Maintenant, nous avons les outils pour définir nos règles de typages,
c'est-à-dire comment nous assignons les types aux termes.

\begin{definition} [Règles de typage]
  Les règles de typage pour le $\lambda$-calcul simplement typé sont
  \begin{mathpar}
    \inferrule
      {(x : T) \in \Gamma}
      {\Gamma \vdash x : T} \quad (\textsc{T-VAR})
    \and
    \inferrule
      {\Gamma, x : T_{1} \vdash t : T_{2}}
      {\Gamma, x : T_{1} \vdash \lambda (x : T_{1}) t : T_{1} \rightarrow T_{2}} \quad (\textsc{T-ABS})
    \and
    \inferrule
      {\Gamma \vdash u : T_{1} \rightarrow T_{2} \\ \Gamma \vdash v : T_{2}}
      {\Gamma \vdash u \, v : T_{2}} \quad (\textsc{T-APP})
  \end{mathpar}
\end{definition}

La règle $(T-VAR)$ est évidente : si $(x, T)$ est dans le contexte, alors
$x$ est de type $T$ sous le contexte $\Gamma$.
Quant à $(T-ABS)$, elle affirme que si le terme $t$ de l'abstraction
$\lambdaExpr{x : T_{1}}{t}$ est de type $T_{2}$, alors l'abstraction est de type
$T_{1} \rightarrow T_{2}$.
Pour finir, $(T-APP)$ type les applications : dans le terme $u \, v$, $u$ doit
être une fonction de type $T_{1} \rightarrow T_{2}$, et $v$ doit être du même
type que $u$ attend, c'est-à-dire $T_{1}$, l'application ayant le type $T_{2}$.

Le typage d'un terme produit des \textit{arbres de dérivation de typage} (ou tout simplement
\textit{une dérivation de typage}). Un arbre de dérivation de typage
est un arbre dont les noeuds sont des jugements de typages, construits à partir
des règles de typages et dont la racine est le jugement de typage du terme à
typer. La racine de l'arbre est également appelée \textit{conclusion}.
La racine de l'arbre de dérivation est le jugement de typage le plus en bas. Les branches
sont annotées par le nom des règles qui permet de déduire le type.

Par exemple, $\lambdaExpr{x : T_{1} \rightarrow T_{2} }{\lambdaExpr{y : T_{1}} x
\, y}$ est de type $(T_{1} \rightarrow T_{2}) \rightarrow T_{1} \rightarrow
T_{2}$. Un arbre de dérivation possible est
  \\

$
\inferrule* [Right=(\textsc{T-APP})]
  {\inferrule* [Left=(\textsc{T-VAR})]
    {x : T_{1} \rightarrow T_{2} \in \Gamma}
    {\Gamma \vdash x : T_{1} \rightarrow T_{2}}
    \\
  \inferrule* [Right=(\textsc{T-VAR})]
    {y : T_{1} \in \Gamma}
    {\Gamma \vdash y : T_{1}}
  }
  {\inferrule* [Right=(\textsc{T-ABS})]
    {\Gamma, x : T_{1} \rightarrow T_{2}, y : T_{1} \vdash x \, y : T_{2}}
    {\inferrule* [Right=(\textsc{T-ABS})]
      {\Gamma, x : T_{1} \rightarrow T_{2}
        \vdash
        \lambdaExpr{y : T_{1}}{x \, y} :
        T_{1} \rightarrow T_{2}
      } 
      {\Gamma \vdash \lambdaExpr{x : T_{1} \rightarrow T_{2}}{\lambdaExpr{y :
            T_{1}}{x \, y}} : (T_{1} \rightarrow
        T_{2}) \rightarrow T_{1} \rightarrow T_{2}
      }
    }
  } 
$


%Le $\lambda$-calcul simplement typé est donc un tuple $(\Lambda, \rightarrow,
%\tau, \Gamma_{\tau})$ où
%\begin{enumerate}
%\item $\Lambda$ est l'ensemble des $\lambda$-termes.
%\item $\rightarrow$ est la relation de $\beta$-réduction.
%\item $\tau$ l'ensemble des types.
%\item $\Gamma$ est le jugement de typage (défini récursivement).
%\end{enumerate}

\section{Sûreté du typage}

Dans cette partie, nous allons aborder deux théorèmes importantes : les
théorèmes de progression et de préservation du typage. En assemblant ces deux
théorèmes, nous en déduisons le principe \og les
programmes\footnote{Un programme est synonyme de terme.}
bien typés ne bloquent pas \fg. Ne pas bloquer signifie que si le programme se
termine (un programme bien typé peut contenir une boucle infinie), alors il
s'évaluera en une valeur du type du programme.

Ces deux théorèmes unifient les deux relations précédemment définies : la
relation de typage et la relation de $\beta$-réduction.

\begin{enumerate}
  \item Progression : si un terme est bien typé, alors soit il s'évalue en une
    valeur, soit il s'évalue en un terme.
    \item Préservation (du typage) : si un terme $t$ de type $T$ s'évalue en un terme $t'$,
      alors $t'$ est de type $T$.
\end{enumerate}

Avant de montrer la préservation et la progression, il est nécessaire de
remarquer certains faits qui découlent immédiatement des règles de typages.

\begin{lemma} [Inversion des règles de typage]
  \begin{enumerate}
    \item Si $\Gamma \vdash x : T$, alors $(x : T) \in \Gamma$
    \item Si $\Gamma \vdash \lambdaExpr{x : T_{1}}{t_{2}} : T$ alors $T = T_{1}
      \rightarrow T_{2}$ pour un $T_{2}$ tel que $t : T_{2}$.
    \item Si $\Gamma \vdash t_{1} t_{2} : T$, alors il existe $T_{1}$
      tel que $t_{1} : T_{1} \rightarrow T$ et $t_{2} : T_{1}$.
  \end{enumerate}
\end{lemma}
  
\begin{proof}
  Ces propositions découlent des règles de typage. En effet, pour la deuxième
  par exemple, la seule règle qui permet d'affirmer que $\Gamma \vdash
  \lambdaExpr{x : T_{1}}{t_{2}} : T$ est $T-ABS$.
\end{proof}

Le lemme d'inversion des règles de typage dit également quelque chose de
fondamentale sur les arbres de typage et qui a une énorme importance lorsque
nous souhaitons implémenter un algorithme de typage\footnote{Nous verrons par la
suite que ce n'est pas tout le temps évident de passer des règles de typage à un
algorithme de typage.}. En effet, les 3 points du
lemmes nous donnent quels sont les possibles fils de la conclusion. Par
exemple, si nous devons montrer que $\lambdaExpr{x : T}{t} : T'$, nous sommes
convaincus, par le lemme d'inversion, que le noeud précédent provient de la
règle $(T-ABS)$. Cela implique que pour un jugement de typage donné, il n'y a au
plus qu'un seul arbre de dérivation.

Une autre remarque importante, et qui découle du fait que les arbres de
dérivations ont uniques, est l'unicité de type. Nous verrons que cette
proposition n'est pas vraie dans tous les calculs.

\begin{theorem} [Unicité du typage]
  \label{chap1-thm:type-unicity}
  Soit $t$ un $\lambda$-terme. Si $t$ est bien typé, alors son type est unique. De plus, il existe au
  plus un arbre de dérivation qui permet de montrer que $t$ a ce type.
\end{theorem}

\begin{proof}
  Supposons que $t$ possède deux types, par exemple $S$ et $T$. Nous avons donc les
  jugements de typage : $\Gamma \vdash t : S$ et $\Gamma \vdash t : T$. Nous procédons
  par induction sur la structure des termes.
  \begin{itemize}
   \item $t$ est une variable $x$. Alors nous avons les jugements de typage $\Gamma \vdash x : S$ et $\Gamma
     \vdash x : T$. Par le lemme d'inversion, nous en déduisons que $(x, S) \in
     \Gamma$ et $(x, T) \in \Gamma$. Comme une variable ne peut apparaître
     qu'une fois dans un contexte, nous en déduisons $S = T$.

   \item $t$ est de la forme $\lambdaExpr{x : T_{1}}{t'}$. Par le lemme
     d'inversion, $S = T_{1} \rightarrow R_{1}$ et $T = T_{1} \rightarrow
     R_{2}$ avec $t' : R_{1}$ et $t' : R_{2}$. Par induction sur $t'$, nous
     déduisons que $R_{1} = R_{2}$. Donc $S = T$.

   \item $t$ est de la forme $u \, v$. Par le lemme d'inversion, il existe
     $T_{1}$ tel que $u$ est de type $T_{1} \rightarrow S$ et de type $T_{1}
     \rightarrow T$ avec $v$ de type $T_{1}$. Par induction
     sur $u$, le type de $u$ est unique donc $S = T$
   \end{itemize}

   L'unicité de l'arbre de dérivation découle immédiatement du lemme d'inversion
   et de la remarque ci-dessus.
\end{proof}

\begin{theorem} [de progression de $\lambda_{\rightarrow}$]
  Soit $t$ un terme bien typé sans variables libre. Alors, soit $t$ est une
  valeur, soit il existe $t'$ tel que $t \rightarrow t'$.
\end{theorem}

\begin{proof}
  Nous procédons par induction sur la structure des termes.
  \begin{itemize}
    \item Le cas d'une variable n'est pas possible. En effet, aucune règle
      d'évaluation n'a comme prémisse une variable.
    \item $t$ est une abstraction. Le résultat est direct car $t$ est une valeur.
    \item $t$ est de la forme $u \, v$. $t$ étant
      bien typé, nous avons le jugement de typage $\vdash t : T$ où $\Gamma$ est
      vide car $t$ ne possède pas de variables libres. Par le lemme
      d'inversion, $u : T_{1} \rightarrow T$ et $v : T_{1}$. Par induction,
      comme $u$ (resp. $v$) est bien typé, $u$ (resp. $v$) est soit une valeur,
      soit s'évalue en un $u'$ (resp. $v'$).
      \begin{itemize}
        \item Si $u$ s'évalue en $u'$, alors $(E-APP1)$ s'applique et $u \, v$
          s'évalue en $u' \, v$.
        \item Si $u$ est une valeur et $v$ s'évalue en $v'$, alors $(E-APP2)$
          s'applique et $u \, v$ s'évalue en $u \, v'$.
        \item Si $u$ et $v$ sont des valeurs, $(E-APPABS)$ s'applique.
      \end{itemize}
  \end{itemize}
\end{proof}

\subsection*{Préservation}

\begin{lemma} [de permutation]
  Soit $\Gamma \vdash t : T$ et soit $\Delta$ une permutation de $\Gamma$. Alors
  $\Delta \vdash t : T$.
\end{lemma}

\begin{proof}
  Par induction sur la structure des termes.
  \begin{itemize}
  \item $t$ est une variable $x$. Par hypothèse, $\Gamma \vdash x : T$. Par le lemme
    d'inversion, $(x, T) \in \Gamma$ d'où $(x, T) \in \Delta$. Par $(T-VAR)$,
    $\Delta \vdash x : T$.
  \item $t = \lambdaExpr{x : T_{1}} t'$. Par hypothèse et le lemme d'inversion,
    $\Gamma \vdash \lambdaExpr{x : T_{1}} t' : T_{1} \rightarrow T_{2}$ et
    $\Gamma, x : T_{1} \vdash t' : T_{2}$. Par hypothèse de récurrence, $\Delta,
    x : T_{1} \vdash t' : T_{2}$. Par $(T-ABS)$, $\Delta \vdash \lambdaExpr{x :
      T_{1}}{t'} : T_{1} \rightarrow T_{2}$.
  \item $t = u \, v$. Nous savons que $\Gamma \vdash u \, v : T$. Par le lemme
    d'inversion, nous obtenons $\Gamma \vdash u : T_{1} \rightarrow T$ et
    $\Gamma \vdash v : T_{1}$. Par hypothèse de récurrence, $\Delta \vdash u :
    T_{1} \rightarrow T$ et $\Delta \vdash v : T_{1}$. Par $(T-APP)$, $\Delta
    \vdash u \, v : T$.
  \end{itemize}
\end{proof}

\begin{lemma} [d'affaiblissement]
  Soit $\Gamma \vdash t : T$ et $x \notin dom(\Gamma)$.

  Alors $\Gamma, x : S \vdash t : T$.
\end{lemma}

\begin{proof}
  Par induction sur la structure des termes.
  \begin{itemize}
  \item $t$ est une variable $y$. Le cas où $y = x$ est impossible car par le
    lemme d'inversion, nous avons $(x, T) \in \Gamma$ et cela contredit
    l'hypothèse que $x \notin \Gamma$. Si $y \neq x$, $(y, T) \in \Gamma$ par le
    lemme d'inversion et par conséquence, $(y, T) \in \Gamma, x : S$ et nous
    concluons en utilisant $(T-VAR)$.
  \item $t = \lambdaExpr{y : T_{1}}{t'}$ tel que $\Gamma \vdash t : T$. Par le
    lemme d'inversion, nous avons $T = T_{1} \rightarrow T_{2}$ et $\Gamma, y :
    T_{1} \vdash t' : T_{2}$. Par hypothèse de récurrence, on a $\Gamma, y :
    T_{1}, x : S \vdash t' : T_{2}$. Par le lemme de permutation, nous avons
    $\Gamma, x : S, y : T_{1} \vdash t' : T_{2}$ et par (T-ABS), nous déduisons
    $\Gamma, x : S \vdash \lambdaExpr{y : T_{1}}{t'} : T_{1} \rightarrow T_{2}$.
    \item $t = u \, v$ tel que $\Gamma \vdash u \, v : T$. Par le lemme
      d'inversion, nous avons $\Gamma \vdash u : T_{1} \rightarrow T$ et $\Gamma
      \vdash v : T_{1}$. Par hypothèse de récurrence, $\Gamma, x : S \vdash u :
      T_{1} \rightarrow T$ et $\Gamma, x : S \vdash v : T_{1}$. Nous concluons
      que $\Gamma, x : S \vdash u \, v : T$ par T-APP.
  \end{itemize}
\end{proof}

\begin{lemma} [de préservation du typage pour la substitution]
  Soit $\Gamma, x : S \vdash t : T$ et $\Gamma \vdash s : S$.

  Alors $\Gamma \vdash [x \rightarrow s] t : T$
\end{lemma}

\begin{proof}
  Nous procédons par une induction sur l'arbre de dérivation $\Gamma, x : S \vdash t : T$.

  \begin{itemize}
  \item $t = z$. Alors, par le lemme d'inversion, $(z, T) \in \Gamma, x : S$.
    Deux cas sont possibles. Si $z = x$, alors $[x \rightarrow s] z = s$ ainsi que
    $S = T$ et nous obtenons le résultat souhaité. Si $z \neq x$,
    alors $[x \rightarrow s] z = z$ et il n'y a rien à montrer car $\Gamma
    \vdash z : T$.
  \item $t = \lambdaExpr{y : T_{1}}{t'}$.
    Sans perte de généralité, nous supposons
      $y \notin FV(s)$ et $x \neq y$. 
    Rappelons que par définition de la $\beta$-réduction,
    \begin{equation*}
      [x \rightarrow s](\lambdaExpr{y : T_{1}}{t'}) = (\lambdaExpr{y : T_{1}})([x \rightarrow s] t')
    \end{equation*}
Alors $T = T_{1} \rightarrow R$ avec
      $\Gamma, x : S, y : T_{1} \vdash t' : R$. Par le lemme de permutation,
      nous avons également $\Gamma, y : T_{1}, x : S \vdash t' : R$. En utilisant le lemme
      d'affaiblissement avec $\Gamma \vdash s : S$, comme $y \notin \Gamma$,
      nous obtenons $\Gamma, y : T_{1} \vdash s : S$.
      Nous appliquons alors l'hypothèse de récurrence avec $t'$ et nous obtenons
      $\Gamma, y : T_{1} \vdash [x \rightarrow s] t' : R$. Par T-ABS, nous avons
      $\Gamma \vdash [x \rightarrow s] (\lambdaExpr{y : T_{1}}{([x \rightarrow s]t')}) : R$ .

    \item $t = u \, v$.
      Rappelons que par définition de la $\beta$-réduction,
      \begin{equation*}
        [x \rightarrow s](u \, v) = ([x \rightarrow s] u) \, ([x \rightarrow s] v)
      \end{equation*}

      Par le lemme d'inversion, nous avons $\Gamma, x : S
      \vdash u : T_{1} \rightarrow T$ et $\Gamma, x : S \vdash v : T_{¡}$. Par
      hypothèse d'induction sur $u$ et $v$, nous avons $\Gamma \vdash [x \rightarrow s]u :
      T_{1} \rightarrow T$ et
      $\Gamma \vdash [x \rightarrow s]v : T_{1}$. Par T-APP et le rappel
      ci-dessus, nous pouvons conclure $\Gamma \vdash [x \rightarrow s](u \, v)
      : T$.
  \end{itemize}
  
\end{proof}

\begin{theorem} [de préservation du typage]
  Soit $\Gamma \vdash t : T$ et $t \rightarrow t'$. Alors $\Gamma \vdash t' :
  T$.
\end{theorem}

\begin{proof}
  Par induction sur l'arbre de dérivation de $\Gamma \vdash t : T$.
  \begin{itemize}
  \item $\Gamma \vdash x : T$. Ce cas n'est pas possible car aucun règle de
    réduction existe pour les variables.
  \item $\Gamma \vdash \lambdaExpr{x : T_{1}}{t'} : T$. Même chose que pour le
    cas des variables.
  \item $\Gamma \vdash u v : T$. Par le lemme d'inversion, nous avons $\Gamma
    \vdash u : T_{1} \rightarrow T$ et $\Gamma \vdash v : T_{1}$. Plusieurs cas possibles:
    \begin{itemize}
    \item $u$ s'évalue en $u'$. Alors, $t' = u' \, v$ par E-APP1. Par hypothèse
      de récurrence sur l'arbre de dérivation $\Gamma \vdash u \, v : T$, nous
      obtenons $\Gamma \vdash u' : T_{1} \rightarrow T$. Par T-APP,
      $\Gamma \vdash u' \, v : T$.
    \item $v$ s'évalue en $v'$ et $u$ est une valeur. Alors, $t' = u \, v'$ par
      E-APP2. Nous appliquons alors le même argument que pour le cas précedent.
    \item $u$ et $v$ sont des valeurs. Posons $u = \lambdaExpr{x : T_{1}} t_{1}$.
      alors $t' = [x \rightarrow v]t_{1}$. Par le lemme d'inversion, nous
      obtenons $\Gamma, x : T_{1} \vdash t_{1} : T$. Par le lemme de
      substitution, nous concluons $\Gamma \vdash [x \rightarrow v]t_{1} : T$.
    \end{itemize}
  \end{itemize}
\end{proof}