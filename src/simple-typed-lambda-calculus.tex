\chapter{$\lambda$-calcul simplement typé.}

Dans le chapitre 1, nous avons défini la syntaxe et la sémantique d'un calcul
appelé le $\lambda$-calcul non typé. Nous allons maintenant ajouter une notion de types à
chaque terme de notre calcul, ce qui nous mènera au $\lambda$-calcul simplement typé.

\section{Typage, contexte de typage et règle d'inférence}

Le typage consiste à classer les termes en fonction de leur nature. Par exemple,
une abstraction est interprétée comme une fonction prenant un paramètre et
renvoyant un terme. Nous représentons cela par le type $\rightarrow$, appelé
couramment \textit{type flèche}. Un type flèche dépend naturellement de deux autres types : le
type du terme qu'il prend en paramètre (disons $T_{1}$) et le type du terme
qu'il retourne (disons $T_{2}$). Dans ce cas, l'abstraction est dite de type
$T_{1} \rightarrow T_{2}$. Un
autre exemple est l'application. Une application $u \, v$ représentant une
application de $v$ à la fonction $u$, il serait naturel de dire que $u$ est un
type flèche dont le type de son paramètre est le type de $v$.

\begin{definition} [Relation de typage]
  Soit $\Lambda$ un ensemble de termes.
  Soit $\tau$ un ensemble, appelé \textbf{ensemble des types}, dont les éléments
  sont notés $T$.

  On définit une relation binaire $R$, appelée \textbf{relation de typage}, entre les
  termes et les éléments de $\tau$.
  
  On dit que \textbf{le terme $t \in \Lambda$ a le type $T \in \tau$} si $(t, T)
  \in R$, noté le plus souvent $t : T$. Si un terme $t$ est en relation avec au
  moins un type $T$, on dit que $t$ est \textbf{bien typé}.
\end{definition}

Cette définition de la relation de typage est générale car il suffit de se
donner un ensemble de termes et un ensemble de types. Dans ce chapitre, nous
allons nous focaliser sur les termes du $\lambda$-calcul non typé. Dans les
prochains chapitres, nous ajouterons des autres termes comme les enregistrements
et nous devrons en conséquence donner un type à ces nouveaux termes.

Dans ce chapitre, nous allons travailler avec l'ensemble des types dit
\textit{simples}.

\begin{definition}
  Soit $B$ un ensemble de type appelé de \textbf{types de bases}.
  L'ensemble des \textbf{types simples}, élément représentée par la lettre $T$,
  est défini par la grammaire suivante:

  \begin{align*}
    T ::= & \, & \text{types} \\
          & \; B & \text{base} \\
          & \; T \rightarrow T & \text{type des fonctions}
  \end{align*}
\end{definition}

L'ensemble $B$ pourrait être vide, et nous nous retrouvons alors avec un langage
où seuls le type des fonctions existent. Cependant, il existe souvent dans les
langages des types dit de bases ou primitifs, c'est-à-dire l'ensemble $B$.

%Le typage est donc un moyen de spécifier l'appartenance de certains
%$\lambda$-termes à un ensemble précis de type et ainsi réduire les opérations
%possibles sur ces $\lambda$-termes.

%Dans le chapitre 1 sur le $\lambda$-calcul non typé, nous avons défini une
%relation d'évaluation, noté $\rightarrow$. Nous pouvons nous demander comment la
%relation de typage est compatible avec la relation $\rightarrow$.

\subsection*{Contexte de typage}

Nous avons déjà mentionné que, naturellement, les abstraction $\lambdaExpr{x}{t}$ ont le type
flèche, par exemple $T_{1} \rightarrow T_{2}$. Cependant, comment pouvons nous
connaître le type des arguments, c'est-à-dire le type du paramètre que la
fonction attend ? Deux solutions sont couramment utilisées : soit ajouter le type
dans le terme de l'abstraction soit étudier le type de corps de la fonction et
en déduire le type que le paramètre devrait avoir.
Dans la suite, nous utiliserons la première solution. Le terme de l'abstraction
se voit alors ajouter un type à son argument et devient $\lambdaExpr{x : T}{t}$.
La syntaxe des termes devient alors:

\begin{align*}
  t ::= & \, & \text{term} \\
        & \; x & \text{var} \\
        & \; t \, t & \text{app} \\
        & \; \lambdaExpr{x : T}{t} & \text{abs}
\end{align*}

Dans une règle de typage, il se peut que certains termes possèdent des variables
libres (comme $\lambda x x y$). Lorsque nous $\beta$-réduisons un terme, il nous
faut connaître chaque type de chaque variable libre (dans notre cas, $y$). Nous
introduisons pour cela \textbf{le contexte de typage} qui fondamentalement est
une suite finie de couple $(x_{i}, T_{i})$ où $x_{i}$ est une variable et
$T_{i}$ est un type.

\begin{definition} [Contexte de typage]
  Un \textbf{contexte de typage}, noté $\Gamma$, est un ensemble fini de couple $(x_{i},
  T_{i})$ où $x_{i}$ est une variable et $T_{i}$ est un type.
  
  L'union d'un contexte de typage $\Gamma$ avec le couple $(x, T)$ est noté
  $\Gamma, x : T$ (à la place de $\Gamma \cup \left\{(x, T)\right\}$).
\end{definition}

\subsection*{Règle et jugement de typage}

\begin{definition} [Règle de typage / jugement de typage]
  Voir la définition récursive de wikipedia :
  \url{https://fr.wikipedia.org/wiki/Lambda-calcul#cite_ref-8}
  Cela permet de voir un jugement de typage comme un triplet $(\Gamma, t, T)$,
  noté $\Gamma \vdash t : T$ qu'on lit \textbf{$t$ est de type $T$ dans le
    contexte $\Gamma$}.
  On définit récursivement un jugement de typage
  \begin{enumerate}
  \item $(x : T) \in \Gamma \implies \Gamma \vdash t : T$
  \item $\Gamma, x : T \vdash t : T_{1} \implies \Gamma, x : T \vdash \lambda (x
    : T) t : T \rightarrow T_{1}$
  \item $\Gamma \vdash u : T_{1} \rightarrow T_{2} \wedge \Gamma \vdash u :
    T_{1} \implies \Gamma \vdash uv : T_{2}$
  \end{enumerate}

   Si $(t, T) \in \Gamma$, on dit alors que $t$ est bien typé dans $\Gamma$.
\end{definition}

Le contexte est utilisé pour faire des hypothèses sur chaque variable libre dans
le $\lambda$-terme $t$. Donc, on ne peut avoir un jugement de typage de type:

$\empty \vdash (\lambda (x : T_{1}) x) y$ car toutes les variables libres (en
l'occurrence ici $y$) du $\lambda$-terme ne sont pas typées dans le contexte
$\empty$ : nous ne connaissons pas le type de $y$.

Comme pour les règles d'évaluation, on écrit la définition d'un jugement de typage comme des
règles d'inférence. La définition d'un jugement de typage devient donc:

\inferrule
{(x : T) \in \Gamma}
{\Gamma \vdash x : T}
\quad (\textsc{T-VAR})

\inferrule{\Gamma, x : T \vdash t : T_{1}}{\Gamma, x : T \vdash
  \lambda (x : T) t : T_{1}}
\quad (\textsc{T-ABS})

\inferrule{\Gamma \vdash u : T_{1} \rightarrow T_{2} \\ \Gamma \vdash v : T_{2}}{\Gamma
  \vdash uv : T_{2}}
\quad (\textsc{T-APP})

Le $\lambda$-calcul simplement typé est donc un tuple $(\Lambda, \rightarrow,
\tau, \Gamma_{\tau})$ où
\begin{enumerate}
\item $\Lambda$ est l'ensemble des $\lambda$-termes.
\item $\rightarrow$ est la relation de $\beta$-réduction.
\item $\tau$ l'ensemble des types.
\item $\Gamma$ est le jugement de typage (défini récursivement).
\end{enumerate}

\section{Syntaxe}

\section{Sémantique et règle de typage}

\section{Sûreté}

Expliquer la préservation et la progression.
Regarder dans le cours de l'ENS à la place ??

Avant de montrer la préservation et la progression, il est nécessaire de
remarquer certains faits qui découlent immédiatement des règles de typages.

\subsection*{Progression}

\begin{lemma} [Inversion des règles de typage]
  \begin{enumerate}
    \item Si $\Gamma \vdash x : T$, alors $(x : T) \in \Gamma$
    \item 
    \item 
    \item 
    \item 
    \item 
  \end{enumerate}
\end{lemma}
  
\begin{proof}
  Evident d'après les règles de typages données.
\end{proof}

Une autre remarque importante sur le calcul $\lambda_{\rightarrow}$ est
l'unicité de type pour les $\lambda$. Cette proposition est tellement
fondamentale que le terme théorème est utilisé. Cependant, cette propriété n'est
pas vraie dans tous les calculs, comme nous le montrerons quand nous
introduirons le sous-typage.

\begin{theorem}
  Tout $\lambda$-terme bien typé possède un type unique.
\end{theorem}

\begin{proof}
  
\end{proof}

\begin{theorem} [de progression de $\lambda_{\rightarrow}$]
  Soit $t$ un terme bien typé sans variable libre. Alors, soit $t$ est une
  valeur, soit il existe $t'$ tel que $t \rightarrow t'$.
\end{theorem}

\begin{proof}
  
\end{proof}

\subsection*{Préservation}

\begin{lemma} [d'affaiblissement]
  Soit $\Gamma \vdash t : T$ et $x \notin dom(\Gamma)$.

  Alors $\Gamma, x : S \vdash t : T$.
\end{lemma}

\begin{proof}
  
\end{proof}

\begin{lemma} [de préservation du typage pour la substitution]
  Soit $\Gamma, x : S \vdash t : T$ et $\Gamma \vdash s : S$.

  Alors $\Gamma \vdash [x \rightarrow s] t : T$
\end{lemma}

\begin{proof}

\end{proof}

\section{Enrichir le calcul avec des types de bases}

Remarquer qu'on peut ajouter d'autres types comme les listes, les records,
etc avec des règles de typages et des règles d'évaluations propres sans que
cela ne change la propriété de soundness.

Nous utiliserons dans la suite la syntaxe
let x = t in u qui est un alias pour une forme de lambda (la donner).
Cette syntaxe nous permet de n'étudier que les applications entre variables.
En effet, si nous avons une expression de la forme (t u), nous pouvons réduire
l'expression sous la forme (x y) avec
let x = t in
let y = u in
x y

Cependant, il faut vérifier que la sémantique reste la même. Je ne pense pas...